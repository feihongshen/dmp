<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<beans xmlns="http://www.springframework.org/schema/beans" xmlns:jaxws="http://cxf.apache.org/jaxws"
	xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context"
	xmlns:jee="http://www.springframework.org/schema/jee" xmlns:tx="http://www.springframework.org/schema/tx"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/aop 
http://www.springframework.org/schema/aop/spring-aop-3.1.xsd         
http://www.springframework.org/schema/beans 
http://www.springframework.org/schema/beans/spring-beans-3.1.xsd         
http://www.springframework.org/schema/context 
http://www.springframework.org/schema/context/spring-context-3.1.xsd         
http://www.springframework.org/schema/jee 
http://www.springframework.org/schema/jee/spring-jee-3.1.xsd         
http://www.springframework.org/schema/tx 
http://www.springframework.org/schema/tx/spring-tx-3.1.xsd 
http://cxf.apache.org/jaxws 
http://cxf.apache.org/schemas/jaxws.xsd
">
	<!-- This will automatically locate any and all property files you have within your classpath, provided 
		they fall under the META-INF/spring directory. The located property files are parsed and their values 
		can then be used within application context files in the form of ${propertyKey}. -->
	<context:property-placeholder location="classpath*:META-INF/spring/*.properties" />
	<!-- This declaration will cause Spring to locate every @Component, @Repository and @Service in your 
		application. In practical terms this allows you to write a POJO and then simply annotate the new POJO 
		as an @Service and Spring will automatically detect, instantiate and dependency inject your service at 
		startup time. Importantly, you can then also have your new service injected into any other class that 
		requires it simply by declaring a field for your service inside the relying class and Spring will inject 
		it. Note that two exclude filters are declared. The first ensures that Spring doesn't spend time introspecting 
		Roo-specific ITD aspects. The second ensures Roo doesn't instantiate your @Controller classes, as these 
		should be instantiated by a web tier application context. Refer to web.xml for more details about the 
		web tier application context setup services. Furthermore, this turns on @Autowired, @PostConstruct etc 
		support. These annotations allow you to use common Spring and Java Enterprise Edition annotations in 
		your classes without needing to do any special configuration. The most commonly used annotation is @Autowired, 
		which instructs Spring to dependency inject an object into your class. -->
	<context:component-scan base-package="cn.explink"></context:component-scan>

	<context:spring-configured />

	<aop:aspectj-autoproxy proxy-target-class="true" />

	<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
		<property name="driverClassName" value="${drivers}" />
		<property name="url" value="${expressurl.url}" />
		<property name="username" value="${expressurl.user}" />
		<property name="password" value="${expressurl.password}" />
		<property name="initialSize" value="25" />
		<property name="maxActive" value="${expressurl.maxconn}" />
		<property name="maxWait" value="60000" />
		<property name="poolPreparedStatements" value="true" />
		<property name="testOnBorrow" value="true" />
		<property name="validationQuery" value="SELECT 1" />
	</bean>


	<tx:annotation-driven transaction-manager="transactionManager" proxy-target-class="true" />
	<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager" >
		<property name="dataSource" ref="dataSource" />
		<property name="nestedTransactionAllowed" value="true"></property>
	</bean>

	<!--1:配置一个JdbcTemplate实例，并将这个“共享的”，“安全的”实例注入到不同的DAO类中去 -->
	<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
		<property name="dataSource" ref="dataSource" />
	</bean>
	
	<bean id="namedParameterJdbcTemplate"
		class="org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate">
		<constructor-arg ref="dataSource" />
	</bean>

	<bean id="validator" class="org.springframework.validation.beanvalidation.LocalValidatorFactoryBean" />
		
	<bean id="healthCheck" class="cn.explink.util.impl.HealthCheckImpl" />
		
	<!-- ==================== 加载cxf配置文件 =================================== -->
	<import resource="classpath:META-INF/cxf/cxf.xml" />
	<import resource="classpath:META-INF/cxf/cxf-extension-soap.xml" />
	<import resource="classpath:META-INF/cxf/cxf-servlet.xml" />


	<jaxws:client id="addressService" serviceClass="cn.explink.service.addressmatch.AddressSyncService"
		address="http://${addressWebserviceIp}/service/AddressSyncService" />
	<jaxws:client id="addressMappingService" serviceClass="cn.explink.service.addressmatch.AddressMappingService"
		address="http://${addressWebserviceIp}/service/AddressMappingService" />
	<jaxws:client id="addressQueryService" serviceClass="cn.explink.service.addressmatch.AddressQueryService"
		address="http://${addressWebserviceIp}/service/AddressQueryService" />
</beans>
